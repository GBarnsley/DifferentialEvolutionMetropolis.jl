<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DifferentialEvolutionMetropolis Documentation · Differential Evolution Metropolis</title><meta name="title" content="DifferentialEvolutionMetropolis Documentation · Differential Evolution Metropolis"/><meta property="og:title" content="DifferentialEvolutionMetropolis Documentation · Differential Evolution Metropolis"/><meta property="twitter:title" content="DifferentialEvolutionMetropolis Documentation · Differential Evolution Metropolis"/><meta name="description" content="Documentation for Differential Evolution Metropolis."/><meta property="og:description" content="Documentation for Differential Evolution Metropolis."/><meta property="twitter:description" content="Documentation for Differential Evolution Metropolis."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Differential Evolution Metropolis</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>DifferentialEvolutionMetropolis Documentation</a><ul class="internal"><li><a class="tocitem" href="#Main-features"><span>Main features</span></a></li><li><a class="tocitem" href="#Next-Steps"><span>Next Steps</span></a></li><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="tutorial/">Sampling from multimodal distributions</a></li><li><a class="tocitem" href="custom/">Customizing your sampler</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>DifferentialEvolutionMetropolis Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DifferentialEvolutionMetropolis Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GBarnsley/DifferentialEvolutionMetropolis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GBarnsley/DifferentialEvolutionMetropolis.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="DifferentialEvolutionMetropolis-Documentation"><a class="docs-heading-anchor" href="#DifferentialEvolutionMetropolis-Documentation">DifferentialEvolutionMetropolis Documentation</a><a id="DifferentialEvolutionMetropolis-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#DifferentialEvolutionMetropolis-Documentation" title="Permalink"></a></h1><p>Tools for sampling from log-densities using differential evolution algorithms.</p><p>See <a href="tutorial/#Sampling-from-multimodal-distributions">Sampling from multimodal distributions</a> and <a href="custom/#Customizing-your-sampler">Customizing your sampler</a> to get started.</p><p>This package is built upon <a href="https://turinglang.org/AbstractMCMC.jl">AbstractMCMC.jl</a> so log-densities should be constructed using that package, and can be used with <a href="https://github.com/tpapp/TransformVariables.jl">TransformVariables.jl</a> or <a href="https://turinglang.org/Bijectors.jl">Bijectors.jl</a> to control the parameter space.</p><p>The other key dependency is <a href="https://juliastats.org/Distributions.jl">Distributions.jl</a>. Almost every parameter in proposals given here are defined via customizable univariate distributions. Values that are fixed are specified via a <a href="https://en.wikipedia.org/wiki/Dirac_delta_function">Dirac distribution</a>, though in the API these can be specified with any real value. As a <em>warning</em> there are some checks on the given distributions, but in the interest of flexibility it is up to the user to ensure that they are suitable for the given parameter. You can disable any checking of your provided distributions with <code>; check_args = false</code> if you really want to ruin your sampler efficiency. Distributions can optionally be used to define your log-density, as in the examples given here. </p><p>As far as I am aware, there is one other package that implements differential evolution MCMC in Julia, <a href="https://github.com/itsdfish/DifferentialEvolutionMCMC.jl/tree/master">DifferentialEvolutionMCMC.jl</a>. I opted to implement my own version as I wanted a more flexible API and the subsampling scheme from DREAM. That&#39;s not to discredit DifferentialEvolutionMCMC.jl, it has many features this package does not, such as being able to work on optimization problems and parameter blocking.</p><h2 id="Main-features"><a class="docs-heading-anchor" href="#Main-features">Main features</a><a id="Main-features-1"></a><a class="docs-heading-anchor-permalink" href="#Main-features" title="Permalink"></a></h2><ul><li>Original differential evolution, snooker, and adaptive subspace sampling (i.e. from DREAM) updates</li><li>Optional parallel tempering (no swaps yet, information is shared by the DE updates!) and annealing</li><li>Composite samplers, can combine any of the implemented updates (in future I&#39;ll wrap other abstractMCMC based samplers)</li><li>Easy to implement your own updates!</li><li>Can output in <code>MCMCChains</code> format, though you use multiple sampling chains (i.e. chains of the DE-chains) these will all be appended together</li></ul><h2 id="Next-Steps"><a class="docs-heading-anchor" href="#Next-Steps">Next Steps</a><a id="Next-Steps-1"></a><a class="docs-heading-anchor-permalink" href="#Next-Steps" title="Permalink"></a></h2><p>A few plans for this package, feel free to suggest features or improvements via <a href="https://github.com/GBarnsley/DifferentialEvolutionMetropolis/issues">issues</a>:</p><ul><li>Implement multi-try and delayed rejection DREAM, I avoided these so far since I have been using these samplers for costly log-densities with relatively few parameters, such as one that solve an ODE.</li><li>Additional diagnostic checks and adaptive schemes.</li></ul><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="custom/#Customizing-your-sampler">Customizing your sampler</a></li><li class="no-marker"><ul><li><a href="custom/#Custom-Stopping-Criteria">Custom Stopping Criteria</a></li><li><a href="custom/#Custom-Proposal-Distributions">Custom Proposal Distributions</a></li><li><a href="custom/#Example:-Using-Custom-Components">Example: Using Custom Components</a></li></ul></li><li><a href="#DifferentialEvolutionMetropolis-Documentation">DifferentialEvolutionMetropolis Documentation</a></li><li class="no-marker"><ul><li><a href="#Main-features">Main features</a></li><li><a href="#Next-Steps">Next Steps</a></li><li><a href="#Contents">Contents</a></li><li><a href="#Functions">Functions</a></li><li><a href="#Index">Index</a></li></ul></li><li><a href="tutorial/#Sampling-from-multimodal-distributions">Sampling from multimodal distributions</a></li><li class="no-marker"><ul><li><a href="tutorial/#Multimodal-Distributions">Multimodal Distributions</a></li><li><a href="tutorial/#Sampling-with-DifferentialEvolutionMetropolis">Sampling with DifferentialEvolutionMetropolis</a></li><li><a href="tutorial/#Custom-Scheme">Custom Scheme</a></li><li><a href="tutorial/#Interpreting-Results">Interpreting Results</a></li></ul></li></ul><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><h3 id="Implemented-Sampling-Schemes"><a class="docs-heading-anchor" href="#Implemented-Sampling-Schemes">Implemented Sampling Schemes</a><a id="Implemented-Sampling-Schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Implemented-Sampling-Schemes" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DifferentialEvolutionMetropolis.deMC"><a class="docstring-binding" href="#DifferentialEvolutionMetropolis.deMC"><code>DifferentialEvolutionMetropolis.deMC</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">deMC(model_wrapper, n_its; kwargs...)</code></pre><p>Run the Differential Evolution Markov Chain (DE-MC) sampler proposed by ter Braak (2006).</p><p>This sampler uses differential evolution updates with optional switching between two scaling factors (<code>γ₁</code> and <code>γ₂</code>) to enable mode switching.</p><p>This implementation varies slightly from the original: updates within a population occur based on the previous positions to enable easy parallelization.</p><p>See doi.org/10.1007/s11222-006-8769-1 for more information.</p><p>The algorithm runs for a fixed number of iterations with optional burn-in.</p><p><strong>Arguments</strong></p><ul><li><code>model_wrapper</code>: LogDensityModel containing the target log-density function</li><li><code>n_its</code>: Number of sampling iterations per chain</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>rng</code>: Random number generator. Defaults to <code>default_rng()</code>.</p></li><li><p><code>n_burnin</code>: Number of burn-in iterations. Defaults to <code>n_its * 5</code>.</p></li><li><p><code>save_burnt</code>: Save burn-in samples in output. Defaults to <code>false</code>.</p></li><li><p><code>γ₁</code>: Primary scaling factor. Defaults to <code>2.38 / sqrt(2 * dim)</code>.</p></li><li><p><code>γ₂</code>: Secondary scaling factor for mode switching. Defaults to 1.0.</p></li><li><p><code>p_γ₂</code>: Probability of using <code>γ₂</code>. Defaults to 0.1.</p></li><li><p><code>chain_type</code>: Type of chain to return (e.g., <code>Any</code>, <code>DifferentialEvolutionOutput</code>, <code>MCMCChains.Chains</code>, or <code>FlexiChains.VNChain</code>). Defaults to <code>DifferentialEvolutionOutput</code>.</p></li><li><p><code>save_final_state</code>: Whether to return the final state along with samples, if true the output will be (samples::chain<em>type, final</em>state). Defaults to <code>false</code>.</p></li></ul><p><strong>Generic DE Arguments</strong></p><ul><li><code>n_chains</code>: Number of parallel chains. Defaults to <code>max(2 * dimension, 3)</code> for adequate mixing.</li><li><code>adapt</code>: Whether to enable adaptive behavior during warm-up (if the sampler supports it). Defaults to <code>true</code>.</li><li><code>initial_position</code>: Starting positions for chains. Can be <code>nothing</code> (random initialization), or a vector of parameter vectors. If the provided vector is smaller than <code>n_chains + n_hot_chains</code>, it will be expanded; if larger and <code>memory=true</code>, excess positions become initial memory. Defaults to <code>nothing</code>.</li><li><code>parallel</code>: Whether to evaluate initial log-densities in parallel. Useful for expensive models. Defaults to <code>false</code>.</li><li><code>n_preallocated_indices</code>: This package provides fast sampling-without-replacement by pre-allocating indices, defaults to 3 (which the most asked for by the implemented samplers). Consider increasing it if you implement your own proposal that calls <code>pick_chains</code> with <code>n_chains &gt; 3</code>.</li><li><code>update_memory</code>: Whether to update the memory with new positions (for memory-based samplers). Defaults to <code>true</code>. Overwrites memory options given at initialization, generally should only be of use if calling <code>step</code> directly.</li><li><code>silent</code>: Suppress informational logging during initialization (e.g., initial position adjustments and   memory setup) when <code>true</code>. Defaults to <code>false</code>.</li></ul><p><strong>Memory-based Sampling Arguments</strong></p><ul><li><code>memory</code>: Whether to use memory-based sampling that stores past positions. Memory-based samplers can be more efficient for high-dimensional problems. Defaults to <code>false</code>.</li><li><code>N₀</code>: Initial memory size for memory-based samplers. Should be ≥ <code>n_chains + n_hot_chains</code>. Defaults to <code>2 * n_chains + n_hot_chains</code>.</li><li><code>memory_size</code>: Maximum number of positions retained per chain in memory. The effective total stored positions is   <code>memory_size * (n_chains + n_hot_chains)</code>. Defaults to <code>1001</code> or <code>2*num_warmup</code> if that is provided here or via <code>sample</code>. Larger sizes can improve proposal diversity but   increase memory usage. Set with consideration of available RAM and expected run length.</li><li><code>memory_refill</code>: Whether to refill memory when full instead of extending the memory, will replace from the start. Defaults to <code>false</code>.</li><li><code>memory_thin_interval</code>: Thinning interval for memory updates. If &gt; 0, only every <code>memory_thin_interval</code>-th position is stored in memory.</li></ul><p><strong>Parallel Tempering and Simulated Annealing Arguments</strong></p><ul><li><code>n_hot_chains</code>: Number of hot chains for parallel tempering. Defaults to 0 (no parallel tempering).</li><li><code>max_temp_pt</code>: Maximum temperature for parallel tempering. Defaults to 2*sqrt(dimension).</li><li><code>max_temp_sa</code>: Maximum temperature for simulated annealing. Defaults to <code>max_temp_pt</code>.</li><li><code>α</code>: Temperature ladder spacing parameter. Controls the geometric spacing between temperatures. Defaults to 1.0.</li><li><code>annealing</code>: Whether to use simulated annealing (temperature decreases over time). Defaults to <code>false</code>.</li><li><code>annealing_steps</code>: Number of annealing steps. Defaults to <code>annealing ? num_warmup : 0</code>.</li><li><code>temperature_ladder</code>: Pre-defined temperature ladder as a vector of vectors. If provided, overrides automatic temperature ladder creation. Defaults to <code>create_temperature_ladder(n_chains, n_hot_chains, α, max_temp_pt, max_temp_sa, annealing_steps)</code>.</li></ul><ul><li><code>kwargs...</code>: Additional keyword arguments passed to <code>AbstractMCMC.sample</code> (e.g., <code>memory_refill</code>, <code>memory_thin_interval</code>, <code>silent</code>). See <a href="https://turinglang.org/AbstractMCMC.jl/stable/api/#Common-keyword-arguments">AbstractMCMC documentation</a>.</li></ul><p><strong>Returns</strong></p><ul><li>depends on <code>chain_type</code>, and <code>save_final_state</code></li></ul><p><strong>Example</strong></p><pre><code class="language- hljs">using DifferentialEvolutionMetropolis, Random, Distributions

# Define a simple log-density function
model_wrapper(θ) = logpdf(MvNormal([0.0, 0.0], I), θ)

# Run differential evolution MCMC
result = deMC(model_wrapper, 1000; n_chains = 10, parallel = false)</code></pre><p><strong>Notes</strong></p><ul><li>For non-memory samplers, <code>n_chains</code> should typically be ≥ dimension for good mixing</li><li>Memory-based samplers can work effectively with fewer chains than the problem dimension</li><li>The function handles dimension mismatches and provides informative warnings</li><li>Initial log-densities are computed automatically for all starting positions</li><li>When using parallel tempering (<code>n_hot_chains &gt; 0</code>), only the cold chains (first <code>n_chains</code>) are returned in the sample, but all chains participate in the sampling process</li><li>Memory-based samplers with parallel tempering may issue warnings since hot chains typically aren&#39;t necessary when using memory</li></ul><p>See also <a href="#DifferentialEvolutionMetropolis.deMCzs"><code>deMCzs</code></a>, <a href="#DifferentialEvolutionMetropolis.DREAMz"><code>DREAMz</code></a>, <a href="#DifferentialEvolutionMetropolis.setup_de_update"><code>setup_de_update</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DifferentialEvolutionMetropolis.jl/blob/7ce0d18f8d8cd546c0541cda143f6fd5f1d37151/src/templates.jl#L1-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DifferentialEvolutionMetropolis.deMCzs"><a class="docstring-binding" href="#DifferentialEvolutionMetropolis.deMCzs"><code>DifferentialEvolutionMetropolis.deMCzs</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">deMCzs(model_wrapper, n_its; kwargs...)</code></pre><p>Run the Differential Evolution Markov Chain with snooker update and historic sampling (DE-MCzs) sampler.</p><p>It combines DE updates with optional snooker moves and uses memory-based sampling to efficiently handle high-dimensional problems with fewer chains.</p><p>Proposed by ter Braak and Vrugt (2008), see doi.org/10.1007/s11222-008-9104-9.</p><p>The algorithm runs for a fixed number of iterations with optional burn-in.</p><p><strong>Arguments</strong></p><ul><li><code>model_wrapper</code>: LogDensityModel containing the target log-density function</li><li><code>n_its</code>: Number of sampling iterations per chain</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>rng</code>: Random number generator. Defaults to <code>default_rng()</code>.</p></li><li><p><code>n_burnin</code>: Number of burn-in iterations. Defaults to <code>n_its * 5</code>.</p></li><li><p><code>γ</code>: Scaling factor for DE updates. Defaults to <code>2.38 / sqrt(2 * dim)</code>.</p></li><li><p><code>γₛ</code>: Scaling factor for snooker updates. Defaults to <code>2.38 / sqrt(2)</code>.</p></li><li><p><code>p_snooker</code>: Probability of snooker moves. Defaults to 0.1.</p></li><li><p><code>β</code>: Noise distribution for DE updates. Defaults to <code>Uniform(-1e-4, 1e-4)</code>.</p></li><li><p><code>chain_type</code>: Type of chain to return (e.g., <code>Any</code>, <code>DifferentialEvolutionOutput</code>, <code>MCMCChains.Chains</code>, or <code>FlexiChains.VNChain</code>). Defaults to <code>DifferentialEvolutionOutput</code>.</p></li><li><p><code>save_final_state</code>: Whether to return the final state along with samples, if true the output will be (samples::chain<em>type, final</em>state). Defaults to <code>false</code>.</p></li></ul><p><strong>Generic DE Arguments</strong></p><ul><li><code>n_chains</code>: Number of parallel chains. Defaults to <code>max(2 * dimension, 3)</code> for adequate mixing.</li><li><code>adapt</code>: Whether to enable adaptive behavior during warm-up (if the sampler supports it). Defaults to <code>true</code>.</li><li><code>initial_position</code>: Starting positions for chains. Can be <code>nothing</code> (random initialization), or a vector of parameter vectors. If the provided vector is smaller than <code>n_chains + n_hot_chains</code>, it will be expanded; if larger and <code>memory=true</code>, excess positions become initial memory. Defaults to <code>nothing</code>.</li><li><code>parallel</code>: Whether to evaluate initial log-densities in parallel. Useful for expensive models. Defaults to <code>false</code>.</li><li><code>n_preallocated_indices</code>: This package provides fast sampling-without-replacement by pre-allocating indices, defaults to 3 (which the most asked for by the implemented samplers). Consider increasing it if you implement your own proposal that calls <code>pick_chains</code> with <code>n_chains &gt; 3</code>.</li><li><code>update_memory</code>: Whether to update the memory with new positions (for memory-based samplers). Defaults to <code>true</code>. Overwrites memory options given at initialization, generally should only be of use if calling <code>step</code> directly.</li><li><code>silent</code>: Suppress informational logging during initialization (e.g., initial position adjustments and   memory setup) when <code>true</code>. Defaults to <code>false</code>.</li></ul><p><strong>Memory-based Sampling Arguments</strong></p><ul><li><code>memory</code>: Whether to use memory-based sampling that stores past positions. Memory-based samplers can be more efficient for high-dimensional problems. Defaults to <code>true</code>.</li><li><code>N₀</code>: Initial memory size for memory-based samplers. Should be ≥ <code>n_chains + n_hot_chains</code>. Defaults to <code>2 * n_chains + n_hot_chains</code>.</li><li><code>memory_size</code>: Maximum number of positions retained per chain in memory. The effective total stored positions is   <code>memory_size * (n_chains + n_hot_chains)</code>. Defaults to <code>1001</code> or <code>2*num_warmup</code> if that is provided here or via <code>sample</code>. Larger sizes can improve proposal diversity but   increase memory usage. Set with consideration of available RAM and expected run length.</li><li><code>memory_refill</code>: Whether to refill memory when full instead of extending the memory, will replace from the start. Defaults to <code>false</code>.</li><li><code>memory_thin_interval</code>: Thinning interval for memory updates. If &gt; 0, only every <code>memory_thin_interval</code>-th position is stored in memory.</li></ul><p><strong>Parallel Tempering and Simulated Annealing Arguments</strong></p><ul><li><code>n_hot_chains</code>: Number of hot chains for parallel tempering. Defaults to 0 (no parallel tempering).</li><li><code>max_temp_pt</code>: Maximum temperature for parallel tempering. Defaults to 2*sqrt(dimension).</li><li><code>max_temp_sa</code>: Maximum temperature for simulated annealing. Defaults to <code>max_temp_pt</code>.</li><li><code>α</code>: Temperature ladder spacing parameter. Controls the geometric spacing between temperatures. Defaults to 1.0.</li><li><code>annealing</code>: Whether to use simulated annealing (temperature decreases over time). Defaults to <code>false</code>.</li><li><code>annealing_steps</code>: Number of annealing steps. Defaults to <code>annealing ? num_warmup : 0</code>.</li><li><code>temperature_ladder</code>: Pre-defined temperature ladder as a vector of vectors. If provided, overrides automatic temperature ladder creation. Defaults to <code>create_temperature_ladder(n_chains, n_hot_chains, α, max_temp_pt, max_temp_sa, annealing_steps)</code>.</li></ul><ul><li><code>kwargs...</code>: Additional keyword arguments passed to <code>AbstractMCMC.sample</code> (e.g., <code>memory_refill</code>, <code>memory_thin_interval</code>, <code>silent</code>). See <a href="https://turinglang.org/AbstractMCMC.jl/stable/api/#Common-keyword-arguments">AbstractMCMC documentation</a>.</li></ul><p><strong>Returns</strong></p><ul><li>depends on <code>chain_type</code>, and <code>save_final_state</code></li></ul><p><strong>Example</strong></p><pre><code class="language- hljs">using DifferentialEvolutionMetropolis, Random, Distributions

# Define a simple log-density function
model_wrapper(θ) = logpdf(MvNormal([0.0, 0.0], I), θ)

# Run differential evolution MCMC
result = deMCzs(model_wrapper, 1000; n_chains = 3)</code></pre><p><strong>Notes</strong></p><ul><li>For non-memory samplers, <code>n_chains</code> should typically be ≥ dimension for good mixing</li><li>Memory-based samplers can work effectively with fewer chains than the problem dimension</li><li>The function handles dimension mismatches and provides informative warnings</li><li>Initial log-densities are computed automatically for all starting positions</li><li>When using parallel tempering (<code>n_hot_chains &gt; 0</code>), only the cold chains (first <code>n_chains</code>) are returned in the sample, but all chains participate in the sampling process</li><li>Memory-based samplers with parallel tempering may issue warnings since hot chains typically aren&#39;t necessary when using memory</li></ul><p>See also <a href="#DifferentialEvolutionMetropolis.deMC"><code>deMC</code></a>, <a href="#DifferentialEvolutionMetropolis.DREAMz"><code>DREAMz</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DifferentialEvolutionMetropolis.jl/blob/7ce0d18f8d8cd546c0541cda143f6fd5f1d37151/src/templates.jl#L97-L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DifferentialEvolutionMetropolis.DREAMz"><a class="docstring-binding" href="#DifferentialEvolutionMetropolis.DREAMz"><code>DifferentialEvolutionMetropolis.DREAMz</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">DREAMz(model_wrapper, n_its; kwargs...)</code></pre><p>Run the Differential Evolution Adaptive Metropolis (DREAMz) sampler.</p><p>This advanced adaptive sampler uses subspace sampling with adaptive crossover probabilities. It can switch between scaling factors and includes outlier chain detection/replacement. The algorithm adapts during warm-up and can use memory-based sampling for efficiency.</p><p>Based on Vrugt et al. (2009), see doi.org/10.1515/IJNSNS.2009.10.3.273.</p><p>The algorithm runs for a fixed number of iterations with optional burn-in.</p><p><strong>Arguments</strong></p><ul><li><code>model_wrapper</code>: LogDensityModel containing the target log-density function</li><li><code>n_its</code>: Number of sampling iterations per chain</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>rng</code>: Random number generator. Defaults to <code>default_rng()</code>.</p></li><li><p><code>n_burnin</code>: Number of burn-in iterations. Defaults to <code>n_its * 5</code>.</p></li><li><p><code>γ₁</code>: Primary scaling factor for subspace updates. Defaults to adaptive.</p></li><li><p><code>γ₂</code>: Secondary scaling factor. Defaults to 1.0.</p></li><li><p><code>p_γ₂</code>: Probability of using <code>γ₂</code>. Defaults to 0.2.</p></li><li><p><code>n_cr</code>: Number of crossover probabilities for adaptation. Defaults to 3.</p></li><li><p><code>cr₁</code>: Crossover probability for <code>γ₁</code>. Defaults to adaptive.</p></li><li><p><code>cr₂</code>: Crossover probability for <code>γ₂</code>. Defaults to adaptive.</p></li><li><p><code>ϵ</code>: Additive noise distribution. Defaults to <code>Uniform(-1e-4, 1e-4)</code>.</p></li><li><p><code>e</code>: Multiplicative noise distribution. Defaults to <code>Normal(0.0, 1e-2)</code>.</p></li><li><p><code>chain_type</code>: Type of chain to return (e.g., <code>Any</code>, <code>DifferentialEvolutionOutput</code>, <code>MCMCChains.Chains</code>, or <code>FlexiChains.VNChain</code>). Defaults to <code>DifferentialEvolutionOutput</code>.</p></li><li><p><code>save_final_state</code>: Whether to return the final state along with samples, if true the output will be (samples::chain<em>type, final</em>state). Defaults to <code>false</code>.</p></li></ul><p><strong>Generic DE Arguments</strong></p><ul><li><code>n_chains</code>: Number of parallel chains. Defaults to <code>max(2 * dimension, 3)</code> for adequate mixing.</li><li><code>adapt</code>: Whether to enable adaptive behavior during warm-up (if the sampler supports it). Defaults to <code>true</code>.</li><li><code>initial_position</code>: Starting positions for chains. Can be <code>nothing</code> (random initialization), or a vector of parameter vectors. If the provided vector is smaller than <code>n_chains + n_hot_chains</code>, it will be expanded; if larger and <code>memory=true</code>, excess positions become initial memory. Defaults to <code>nothing</code>.</li><li><code>parallel</code>: Whether to evaluate initial log-densities in parallel. Useful for expensive models. Defaults to <code>false</code>.</li><li><code>n_preallocated_indices</code>: This package provides fast sampling-without-replacement by pre-allocating indices, defaults to 3 (which the most asked for by the implemented samplers). Consider increasing it if you implement your own proposal that calls <code>pick_chains</code> with <code>n_chains &gt; 3</code>.</li><li><code>update_memory</code>: Whether to update the memory with new positions (for memory-based samplers). Defaults to <code>true</code>. Overwrites memory options given at initialization, generally should only be of use if calling <code>step</code> directly.</li><li><code>silent</code>: Suppress informational logging during initialization (e.g., initial position adjustments and   memory setup) when <code>true</code>. Defaults to <code>false</code>.</li></ul><p><strong>Memory-based Sampling Arguments</strong></p><ul><li><code>memory</code>: Whether to use memory-based sampling that stores past positions. Memory-based samplers can be more efficient for high-dimensional problems. Defaults to <code>true</code>.</li><li><code>N₀</code>: Initial memory size for memory-based samplers. Should be ≥ <code>n_chains + n_hot_chains</code>. Defaults to <code>2 * n_chains + n_hot_chains</code>.</li><li><code>memory_size</code>: Maximum number of positions retained per chain in memory. The effective total stored positions is   <code>memory_size * (n_chains + n_hot_chains)</code>. Defaults to <code>1001</code> or <code>2*num_warmup</code> if that is provided here or via <code>sample</code>. Larger sizes can improve proposal diversity but   increase memory usage. Set with consideration of available RAM and expected run length.</li><li><code>memory_refill</code>: Whether to refill memory when full instead of extending the memory, will replace from the start. Defaults to <code>false</code>.</li><li><code>memory_thin_interval</code>: Thinning interval for memory updates. If &gt; 0, only every <code>memory_thin_interval</code>-th position is stored in memory.</li></ul><p><strong>Parallel Tempering and Simulated Annealing Arguments</strong></p><ul><li><code>n_hot_chains</code>: Number of hot chains for parallel tempering. Defaults to 0 (no parallel tempering).</li><li><code>max_temp_pt</code>: Maximum temperature for parallel tempering. Defaults to 2*sqrt(dimension).</li><li><code>max_temp_sa</code>: Maximum temperature for simulated annealing. Defaults to <code>max_temp_pt</code>.</li><li><code>α</code>: Temperature ladder spacing parameter. Controls the geometric spacing between temperatures. Defaults to 1.0.</li><li><code>annealing</code>: Whether to use simulated annealing (temperature decreases over time). Defaults to <code>false</code>.</li><li><code>annealing_steps</code>: Number of annealing steps. Defaults to <code>annealing ? num_warmup : 0</code>.</li><li><code>temperature_ladder</code>: Pre-defined temperature ladder as a vector of vectors. If provided, overrides automatic temperature ladder creation. Defaults to <code>create_temperature_ladder(n_chains, n_hot_chains, α, max_temp_pt, max_temp_sa, annealing_steps)</code>.</li></ul><ul><li><code>kwargs...</code>: Additional keyword arguments passed to <code>AbstractMCMC.sample</code> (e.g., <code>memory_refill</code>, <code>memory_thin_interval</code>, <code>silent</code>). See <a href="https://turinglang.org/AbstractMCMC.jl/stable/api/#Common-keyword-arguments">AbstractMCMC documentation</a>.</li></ul><p><strong>Returns</strong></p><ul><li>depends on <code>chain_type</code>, and <code>save_final_state</code></li></ul><p><strong>Example</strong></p><pre><code class="language- hljs">using DifferentialEvolutionMetropolis, Random, Distributions

# Define a simple log-density function
model_wrapper(θ) = logpdf(MvNormal([0.0, 0.0], I), θ)

# Run DREAM with subspace sampling
result = DREAMz(model_wrapper, 1000; n_chains = 10, memory = false)</code></pre><p><strong>Notes</strong></p><ul><li>For non-memory samplers, <code>n_chains</code> should typically be ≥ dimension for good mixing</li><li>Memory-based samplers can work effectively with fewer chains than the problem dimension</li><li>The function handles dimension mismatches and provides informative warnings</li><li>Initial log-densities are computed automatically for all starting positions</li><li>When using parallel tempering (<code>n_hot_chains &gt; 0</code>), only the cold chains (first <code>n_chains</code>) are returned in the sample, but all chains participate in the sampling process</li><li>Memory-based samplers with parallel tempering may issue warnings since hot chains typically aren&#39;t necessary when using memory</li></ul><p>See also <a href="#DifferentialEvolutionMetropolis.deMC"><code>deMC</code></a>, <a href="#DifferentialEvolutionMetropolis.deMCzs"><code>deMCzs</code></a>, <a href="#DifferentialEvolutionMetropolis.setup_subspace_sampling"><code>setup_subspace_sampling</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DifferentialEvolutionMetropolis.jl/blob/7ce0d18f8d8cd546c0541cda143f6fd5f1d37151/src/templates.jl#L190-L226">source</a></section></details></article><h3 id="Setup-Functions"><a class="docs-heading-anchor" href="#Setup-Functions">Setup Functions</a><a id="Setup-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-Functions" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DifferentialEvolutionMetropolis.setup_sampler_scheme"><a class="docstring-binding" href="#DifferentialEvolutionMetropolis.setup_sampler_scheme"><code>DifferentialEvolutionMetropolis.setup_sampler_scheme</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Create a composite sampler scheme from multiple differential evolution update steps.</p><p>The update method used in each iteration for each chain is randomly selected from the provided update steps according to their weights. This allows combining different sampling strategies (e.g., DE updates with snooker updates) in a single sampler.</p><p><strong>Arguments</strong></p><ul><li><code>updates...</code>: One or more differential evolution sampler objects created by functions like <a href="#DifferentialEvolutionMetropolis.setup_de_update"><code>setup_de_update</code></a>, <a href="#DifferentialEvolutionMetropolis.setup_snooker_update"><code>setup_snooker_update</code></a>, <a href="#DifferentialEvolutionMetropolis.setup_subspace_sampling"><code>setup_subspace_sampling</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>w</code>: Vector of weights for each update step. If not provided, all updates are chosen with equal probability. Weights must be non-negative and will be automatically normalized.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>DifferentialEvolutionCompositeSampler</code> that can be used with <code>AbstractMCMC.sample</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language- hljs">using DifferentialEvolutionMetropolis

# Only snooker updates
sampler1 = setup_sampler_scheme(setup_snooker_update())

# DE and Snooker with equal probability
sampler2 = setup_sampler_scheme(setup_de_update(), setup_snooker_update())

# Snooker 10% of the time, DE 90% of the time
sampler3 = setup_sampler_scheme(setup_de_update(), setup_snooker_update(); w = [0.9, 0.1])</code></pre><p>See also <a href="#DifferentialEvolutionMetropolis.setup_de_update"><code>setup_de_update</code></a>, <a href="#DifferentialEvolutionMetropolis.setup_snooker_update"><code>setup_snooker_update</code></a>, <a href="#DifferentialEvolutionMetropolis.setup_subspace_sampling"><code>setup_subspace_sampling</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DifferentialEvolutionMetropolis.jl/blob/7ce0d18f8d8cd546c0541cda143f6fd5f1d37151/src/composite_sampler.jl#L1-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DifferentialEvolutionMetropolis.setup_de_update"><a class="docstring-binding" href="#DifferentialEvolutionMetropolis.setup_de_update"><code>DifferentialEvolutionMetropolis.setup_de_update</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Set up a Differential Evolution (DE) update step for MCMC sampling.</p><p>Creates a sampler that proposes new states by adding scaled difference vectors between randomly selected chains plus small noise. This is the core update mechanism from the original DE-MC algorithm by ter Braak (2006).</p><p>See doi.org/10.1007/s11222-006-8769-1 for more information.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>γ</code>: Scaling factor for the difference vector. Can be a <code>Real</code> (fixed value), a <code>UnivariateDistribution</code> (random scaling), or <code>nothing</code> (automatic based on <code>n_dims</code>). Defaults to <code>nothing</code>.</li><li><code>β</code>: Distribution for small noise added to proposals. Must be a univariate continuous distribution. Defaults to <code>Uniform(-1e-4, 1e-4)</code>.</li><li><code>n_dims</code>: Problem dimension used for automatic <code>γ</code> selection. If &gt; 0 and <code>γ</code> is <code>nothing</code>, sets <code>γ</code> to the theoretically optimal <code>2.38 / sqrt(2 * n_dims)</code>. If ≤ 0, uses <code>Uniform(0.8, 1.2)</code>. Defaults to 0.</li><li><code>check_args</code>: Whether to validate input distributions. Defaults to <code>true</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>DifferentialEvolutionSampler</code> that can be used with <a href="#DifferentialEvolutionMetropolis.setup_sampler_scheme"><code>setup_sampler_scheme</code></a> or <a href="#AbstractMCMC.step"><code>step</code></a> or <a href="https://turinglang.org/AbstractMCMC.jl/dev/api/#Common-keyword-arguments"><code>sample</code> from AbstractMCMC</a>.</li></ul><p><strong>Example</strong></p><pre><code class="language- hljs">using DifferentialEvolutionMetropolis, Distributions

# Setup differential evolution update with custom parameters
de_update = setup_de_update(γ = 1.0, β = Normal(0.0, 0.01))</code></pre><p>See also <a href="#DifferentialEvolutionMetropolis.setup_snooker_update"><code>setup_snooker_update</code></a>, <a href="#DifferentialEvolutionMetropolis.setup_subspace_sampling"><code>setup_subspace_sampling</code></a>, <a href="#DifferentialEvolutionMetropolis.setup_sampler_scheme"><code>setup_sampler_scheme</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DifferentialEvolutionMetropolis.jl/blob/7ce0d18f8d8cd546c0541cda143f6fd5f1d37151/src/differential_evolution_update.jl#L6-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DifferentialEvolutionMetropolis.setup_snooker_update"><a class="docstring-binding" href="#DifferentialEvolutionMetropolis.setup_snooker_update"><code>DifferentialEvolutionMetropolis.setup_snooker_update</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Set up a Snooker update step for MCMC sampling.</p><p>Creates a sampler that proposes moves along the line connecting the current position to a projection point, scaled by the difference between two other randomly selected chains. This update can help with sampling from distributions with complex geometries by making larger moves in effective directions.</p><p>See doi.org/10.1007/s11222-008-9104-9 for more information.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>γ</code>: Scaling factor for the projection. Can be a <code>Real</code> (fixed value), a <code>UnivariateDistribution</code> (random scaling), or <code>nothing</code> (automatic based on <code>deterministic_γ</code>). Defaults to <code>nothing</code>.</li><li><code>deterministic_γ</code>: When <code>γ</code> is <code>nothing</code>, determines the automatic value. If <code>true</code>, uses the theoretically optimal <code>2.38 / sqrt(2)</code>. If <code>false</code>, uses <code>Uniform(0.8, 1.2)</code>. Defaults to <code>true</code>.</li><li><code>check_args</code>: Whether to validate input distributions. Defaults to <code>true</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>DifferentialEvolutionSnookerSampler</code> that can be used with <a href="#DifferentialEvolutionMetropolis.setup_sampler_scheme"><code>setup_sampler_scheme</code></a> or <a href="#AbstractMCMC.step"><code>step</code></a> or <a href="https://turinglang.org/AbstractMCMC.jl/dev/api/#Common-keyword-arguments"><code>sample</code> from AbstractMCMC</a>.</li></ul><p><strong>Example</strong></p><pre><code class="language- hljs">using DifferentialEvolutionMetropolis, Distributions

# Setup snooker update with custom gamma distribution
snooker_update = setup_snooker_update(γ = Uniform(0.1, 2.0))</code></pre><p>See also <a href="#DifferentialEvolutionMetropolis.setup_de_update"><code>setup_de_update</code></a>, <a href="#DifferentialEvolutionMetropolis.setup_subspace_sampling"><code>setup_subspace_sampling</code></a>, <a href="#DifferentialEvolutionMetropolis.setup_sampler_scheme"><code>setup_sampler_scheme</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DifferentialEvolutionMetropolis.jl/blob/7ce0d18f8d8cd546c0541cda143f6fd5f1d37151/src/snooker_update.jl#L5-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DifferentialEvolutionMetropolis.setup_subspace_sampling"><a class="docstring-binding" href="#DifferentialEvolutionMetropolis.setup_subspace_sampling"><code>DifferentialEvolutionMetropolis.setup_subspace_sampling</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Set up a Subspace Sampling (DREAM-like) update step for MCMC sampling.</p><p>Creates a sampler that updates only a random subset of parameters in each iteration, using multiple scaled difference vectors. The crossover probability determines which parameters to update and can be adapted during warm-up for improved efficiency.</p><p>See doi.org/10.1515/IJNSNS.2009.10.3.273 for more information.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>γ</code>: Scaling factor for the difference vector sum. If <code>nothing</code> (default), uses the adaptive formula <code>2.38 / sqrt(2 * δ * d)</code> where <code>d</code> is the number of updated dimensions. If a <code>Real</code> is provided, uses that fixed value throughout sampling.</li><li><code>cr</code>: Crossover probability for parameter selection. Can be a <code>Real</code> (fixed probability), <code>nothing</code> (adaptive using <code>n_cr</code> values), or a <code>UnivariateDistribution</code>. If cr is a <code>DiscreteNonParametric</code> then it those values can also be adapted. Defaults to <code>nothing</code>.</li><li><code>n_cr</code>: Number of crossover probabilities to adapt between when <code>cr</code> is <code>nothing</code>. Higher values allow more fine-tuned adaptation. Defaults to 3.</li><li><code>δ</code>: Number of difference vectors to sum. Can be an <code>Integer</code> (fixed) or a <code>DiscreteUnivariateDistribution</code> (random). Defaults to <code>DiscreteUniform(1, 3)</code>.</li><li><code>ϵ</code>: Distribution for small additive noise in the selected subspace. Defaults to <code>Uniform(-1e-4, 1e-4)</code>.</li><li><code>e</code>: Distribution for multiplicative noise <code>(1 + e)</code> applied to the difference vector sum. Defaults to <code>Normal(0.0, 1e-2)</code>.</li><li><code>check_args</code>: Whether to validate input distributions. Defaults to <code>true</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A subspace sampler that can be used with <a href="#DifferentialEvolutionMetropolis.setup_sampler_scheme"><code>setup_sampler_scheme</code></a> or <a href="#AbstractMCMC.step"><code>step</code></a> or <a href="https://turinglang.org/AbstractMCMC.jl/dev/api/#Common-keyword-arguments"><code>sample</code> from AbstractMCMC</a>.</li></ul><p><strong>Example</strong></p><pre><code class="language- hljs">using DifferentialEvolutionMetropolis, Distributions

# Setup subspace sampling with custom crossover rate and delta
subspace_config = setup_subspace_sampling(cr = Beta(1, 2), δ = 2)</code></pre><p>See also <a href="#DifferentialEvolutionMetropolis.setup_de_update"><code>setup_de_update</code></a>, <a href="#DifferentialEvolutionMetropolis.setup_snooker_update"><code>setup_snooker_update</code></a>, <a href="#DifferentialEvolutionMetropolis.setup_sampler_scheme"><code>setup_sampler_scheme</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DifferentialEvolutionMetropolis.jl/blob/7ce0d18f8d8cd546c0541cda143f6fd5f1d37151/src/subspace_update.jl#L22-L59">source</a></section></details></article><h3 id="Core-Sampling-Functions"><a class="docs-heading-anchor" href="#Core-Sampling-Functions">Core Sampling Functions</a><a id="Core-Sampling-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Sampling-Functions" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="AbstractMCMC.step"><a class="docstring-binding" href="#AbstractMCMC.step"><code>AbstractMCMC.step</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">step(rng, model_wrapper, sampler, state; parallel=false, update_memory=true, kwargs...)</code></pre><p>Perform a single MCMC step using differential evolution sampling.</p><p>This is the core sampling function that proposes new states for all chains and accepts or rejects them according to the Metropolis criterion. For adaptive samplers, the function automatically fixes adaptive parameters before sampling.</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: Random number generator</li><li><code>model_wrapper</code>: LogDensityModel containing the target log-density function</li><li><code>sampler</code>: Differential evolution sampler (any AbstractDifferentialEvolutionSampler)</li><li><code>state</code>: Current state of all chains</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parallel</code>: Whether to run chains in parallel using threading. Defaults to <code>false</code>. Advisable for slow models.</li><li><code>update_memory</code>: Whether to update the memory with new positions (for memory-based samplers). Defaults to <code>true</code>. Over writes memory options given at initialization.</li><li><code>kwargs...</code>: Additional keyword arguments passed to update functions (see https://turinglang.org/AbstractMCMC.jl/stable/api/#Common-keyword-arguments)</li></ul><p><strong>Returns</strong></p><ul><li><code>sample</code>: DifferentialEvolutionSample containing new positions and log-densities</li><li><code>new_state</code>: Updated state for the next iteration</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sample, new_state = step(rng, model, sampler, state; parallel=true)</code></pre><p>See also <a href="#AbstractMCMC.step_warmup"><code>step_warmup</code></a>, <a href="https://turinglang.org/AbstractMCMC.jl/dev/api/#Common-keyword-arguments"><code>sample</code> from AbstractMCMC</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DifferentialEvolutionMetropolis.jl/blob/7ce0d18f8d8cd546c0541cda143f6fd5f1d37151/src/chains.jl#L168-L198">source</a></section><section><div><pre><code class="language-julia hljs">step(rng, model_wrapper, sampler; n_chains, memory=true, N₀, adapt=true, initial_position=nothing, parallel=false, kwargs...)</code></pre><p>Initialize differential evolution sampling by setting up chains and computing initial state.</p><p>This function serves as the entry point for differential evolution MCMC sampling. It handles chain initialization, memory setup for memory-based samplers, adaptive state initialization, and returns the initial sample and state that can be used with <code>AbstractMCMC.sample</code>.</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: Random number generator</li><li><code>model_wrapper</code>: LogDensityModel containing the target log-density function</li><li><code>sampler</code>: Differential evolution sampler to use</li></ul><p><strong>Keyword Arguments</strong></p><p><strong>Generic DE Arguments</strong></p><ul><li><code>n_chains</code>: Number of parallel chains. Defaults to <code>max(2 * dimension, 3)</code> for adequate mixing.</li><li><code>adapt</code>: Whether to enable adaptive behavior during warm-up (if the sampler supports it). Defaults to <code>true</code>.</li><li><code>initial_position</code>: Starting positions for chains. Can be <code>nothing</code> (random initialization), or a vector of parameter vectors. If the provided vector is smaller than <code>n_chains + n_hot_chains</code>, it will be expanded; if larger and <code>memory=true</code>, excess positions become initial memory. Defaults to <code>nothing</code>.</li><li><code>parallel</code>: Whether to evaluate initial log-densities in parallel. Useful for expensive models. Defaults to <code>false</code>.</li><li><code>n_preallocated_indices</code>: This package provides fast sampling-without-replacement by pre-allocating indices, defaults to 3 (which the most asked for by the implemented samplers). Consider increasing it if you implement your own proposal that calls <code>pick_chains</code> with <code>n_chains &gt; 3</code>.</li><li><code>update_memory</code>: Whether to update the memory with new positions (for memory-based samplers). Defaults to <code>true</code>. Overwrites memory options given at initialization, generally should only be of use if calling <code>step</code> directly.</li><li><code>silent</code>: Suppress informational logging during initialization (e.g., initial position adjustments and   memory setup) when <code>true</code>. Defaults to <code>false</code>.</li></ul><p><strong>Memory-based Sampling Arguments</strong></p><ul><li><code>memory</code>: Whether to use memory-based sampling that stores past positions. Memory-based samplers can be more efficient for high-dimensional problems. Defaults to <code>true</code>.</li><li><code>N₀</code>: Initial memory size for memory-based samplers. Should be ≥ <code>n_chains + n_hot_chains</code>. Defaults to <code>2 * n_chains + n_hot_chains</code>.</li><li><code>memory_size</code>: Maximum number of positions retained per chain in memory. The effective total stored positions is   <code>memory_size * (n_chains + n_hot_chains)</code>. Defaults to <code>1001</code> or <code>2*num_warmup</code> if that is provided here or via <code>sample</code>. Larger sizes can improve proposal diversity but   increase memory usage. Set with consideration of available RAM and expected run length.</li><li><code>memory_refill</code>: Whether to refill memory when full instead of extending the memory, will replace from the start. Defaults to <code>false</code>.</li><li><code>memory_thin_interval</code>: Thinning interval for memory updates. If &gt; 0, only every <code>memory_thin_interval</code>-th position is stored in memory.</li></ul><p><strong>Parallel Tempering and Simulated Annealing Arguments</strong></p><ul><li><code>n_hot_chains</code>: Number of hot chains for parallel tempering. Defaults to 0 (no parallel tempering).</li><li><code>max_temp_pt</code>: Maximum temperature for parallel tempering. Defaults to 2*sqrt(dimension).</li><li><code>max_temp_sa</code>: Maximum temperature for simulated annealing. Defaults to <code>max_temp_pt</code>.</li><li><code>α</code>: Temperature ladder spacing parameter. Controls the geometric spacing between temperatures. Defaults to 1.0.</li><li><code>annealing</code>: Whether to use simulated annealing (temperature decreases over time). Defaults to <code>false</code>.</li><li><code>annealing_steps</code>: Number of annealing steps. Defaults to <code>annealing ? num_warmup : 0</code>.</li><li><code>temperature_ladder</code>: Pre-defined temperature ladder as a vector of vectors. If provided, overrides automatic temperature ladder creation. Defaults to <code>create_temperature_ladder(n_chains, n_hot_chains, α, max_temp_pt, max_temp_sa, annealing_steps)</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>sample</code>: DifferentialEvolutionSample containing initial positions and log-densities</li><li><code>state</code>: Initial state (DifferentialEvolutionState) ready for sampling</li></ul><p><strong>Examples</strong></p><pre><code class="language- hljs">using DifferentialEvolutionMetropolis, Random, Distributions

# Setup
rng = Random.default_rng()
model_wrapper(θ) = logpdf(MvNormal([0.0, 0.0], I), θ)
sampler = deMCzs()

# Basic initialization with default settings
sample, state = step(rng, model_wrapper, sampler)

# Custom number of chains with memory disabled
sample2, state2 = step(rng, model_wrapper, sampler; n_chains=10, memory=false)

# With custom initial positions
init_pos = [randn(2) for _ in 1:8]
sample3, state3 = step(rng, model_wrapper, sampler; initial_position=init_pos)</code></pre><p><strong>Notes</strong></p><ul><li>For non-memory samplers, <code>n_chains</code> should typically be ≥ dimension for good mixing</li><li>Memory-based samplers can work effectively with fewer chains than the problem dimension</li><li>The function handles dimension mismatches and provides informative warnings</li><li>Initial log-densities are computed automatically for all starting positions</li><li>When using parallel tempering (<code>n_hot_chains &gt; 0</code>), only the cold chains (first <code>n_chains</code>) are returned in the sample, but all chains participate in the sampling process</li><li>Memory-based samplers with parallel tempering may issue warnings since hot chains typically aren&#39;t necessary when using memory</li></ul><p>See also <a href="https://turinglang.org/AbstractMCMC.jl/dev/api/#Common-keyword-arguments"><code>sample</code> from AbstractMCMC</a>, <a href="#DifferentialEvolutionMetropolis.deMC"><code>deMC</code></a>, <a href="#DifferentialEvolutionMetropolis.deMCzs"><code>deMCzs</code></a>, <a href="#DifferentialEvolutionMetropolis.DREAMz"><code>DREAMz</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DifferentialEvolutionMetropolis.jl/blob/7ce0d18f8d8cd546c0541cda143f6fd5f1d37151/src/chains.jl#L339-L385">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractMCMC.step_warmup"><a class="docstring-binding" href="#AbstractMCMC.step_warmup"><code>AbstractMCMC.step_warmup</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">step_warmup(rng, model_wrapper, sampler, state; parallel=false, kwargs...)</code></pre><p>Perform a single MCMC step during the warm-up (adaptive) phase.</p><p>During warm-up, this function performs the same sampling as <a href="#AbstractMCMC.step"><code>step</code></a> but also updates adaptive parameters. For subspace samplers, it adapts crossover probabilities based on the effectiveness of different parameter subsets.</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: Random number generator</li><li><code>model_wrapper</code>: LogDensityModel containing the target log-density function</li><li><code>sampler</code>: Adaptive differential evolution sampler</li><li><code>state</code>: Current state including adaptive parameters</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>update_memory</code>: Whether to update the memory with new positions (for memory-based samplers). Defaults to <code>true</code>. Useful if memory has grown too large.</li><li><code>parallel</code>: Whether to run chains in parallel using threading. Defaults to <code>false</code>.</li><li><code>kwargs...</code>: Additional keyword arguments passed to update functions</li></ul><p><strong>Returns</strong></p><ul><li><code>sample</code>: DifferentialEvolutionSample containing new positions and log-densities</li><li><code>new_state</code>: Updated state with adapted parameters for the next iteration</li></ul><p><strong>Example</strong></p><pre><code class="language- hljs">using DifferentialEvolutionMetropolis, Random, Distributions

# Setup for warmup step example
rng = Random.default_rng()
model_wrapper(θ) = logpdf(MvNormal([0.0, 0.0], I), θ)
sampler = DREAMz()

# Initialize state (this would typically be done by AbstractMCMC.sample)
# sample, new_state = step_warmup(rng, model_wrapper, sampler, state; parallel=false)</code></pre><p>See also <a href="#AbstractMCMC.step"><code>step</code></a>, <a href="#DifferentialEvolutionMetropolis.fix_sampler"><code>fix_sampler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DifferentialEvolutionMetropolis.jl/blob/7ce0d18f8d8cd546c0541cda143f6fd5f1d37151/src/subspace_adaptive_update.jl#L73-L112">source</a></section><section><div><pre><code class="language-julia hljs">step_warmup(rng, model_wrapper, sampler, state; kwargs...)</code></pre><p>Perform a single MCMC step during warm-up for composite samplers.</p><p>For composite samplers, this function randomly selects one of the component update methods, performs a warm-up step with that method, and updates the corresponding adaptive state while preserving other component states.</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: Random number generator</li><li><code>model_wrapper</code>: LogDensityModel containing the target log-density function</li><li><code>sampler</code>: Composite differential evolution sampler</li><li><code>state</code>: Current state with composite adaptive parameters</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>update_memory</code>: Whether to update the memory with new positions (for memory-based samplers). Defaults to <code>true</code>. Useful if memory has grown too large.</li><li><code>kwargs...</code>: Additional keyword arguments passed to component update functions</li></ul><p><strong>Returns</strong></p><ul><li><code>sample</code>: DifferentialEvolutionSample containing new positions and log-densities</li><li><code>new_state</code>: Updated state with adapted parameters for the selected component</li></ul><p>See also <a href="#AbstractMCMC.step_warmup"><code>step_warmup</code></a>, <a href="#DifferentialEvolutionMetropolis.setup_sampler_scheme"><code>setup_sampler_scheme</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DifferentialEvolutionMetropolis.jl/blob/7ce0d18f8d8cd546c0541cda143f6fd5f1d37151/src/composite_sampler.jl#L100-L125">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DifferentialEvolutionMetropolis.fix_sampler"><a class="docstring-binding" href="#DifferentialEvolutionMetropolis.fix_sampler"><code>DifferentialEvolutionMetropolis.fix_sampler</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fix_sampler(sampler::AbstractDifferentialEvolutionSampler, adaptive_state::AbstractDifferentialEvolutionAdaptiveState)</code></pre><p>Fix adaptive parameters of a sampler to their current adapted values.</p><p>For non-adaptive samplers, returns the sampler unchanged. For adaptive samplers, returns a new sampler with the adaptive parameters fixed to their current values in the <code>adaptive_state</code>.</p><p><strong>Arguments</strong></p><ul><li><code>sampler</code>: The differential evolution sampler to fix</li><li><code>adaptive_state</code>: The adaptive state containing current parameter values</li></ul><p><strong>Returns</strong></p><ul><li>A sampler with fixed (non-adaptive) parameters</li></ul><p><strong>Example</strong></p><pre><code class="language- hljs">using DifferentialEvolutionMetropolis, Random, Distributions

# This function is typically used after warmup/adaptation phase
# fixed_sampler = fix_sampler(adaptive_sampler, state.adaptive_state)</code></pre><p>See also <a href="#DifferentialEvolutionMetropolis.fix_sampler_state"><code>fix_sampler_state</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DifferentialEvolutionMetropolis.jl/blob/7ce0d18f8d8cd546c0541cda143f6fd5f1d37151/src/chains.jl#L241-L266">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DifferentialEvolutionMetropolis.fix_sampler_state"><a class="docstring-binding" href="#DifferentialEvolutionMetropolis.fix_sampler_state"><code>DifferentialEvolutionMetropolis.fix_sampler_state</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fix_sampler_state(sampler::AbstractDifferentialEvolutionSampler, state::DifferentialEvolutionState)</code></pre><p>Fix adaptive sampler parameters and return a corresponding non-adaptive state.</p><p>Takes an adaptive sampler and state, fixes the sampler&#39;s adaptive parameters to their current values, and returns both the fixed sampler and a simplified state without adaptive components.</p><p><strong>Arguments</strong></p><ul><li><code>sampler</code>: The differential evolution sampler (potentially adaptive)</li><li><code>state</code>: The current sampler state (DifferentialEvolutionState)</li></ul><p><strong>Returns</strong></p><ul><li><code>fixed_sampler</code>: Sampler with adaptive parameters fixed to current values</li><li><code>fixed_state</code>: State without adaptive components</li></ul><p><strong>Example</strong></p><pre><code class="language- hljs">using DifferentialEvolutionMetropolis, Random, Distributions

# This function is typically used after warmup/adaptation phase
# fixed_sampler, fixed_state = fix_sampler_state(sampler, state)</code></pre><p>See also <a href="#DifferentialEvolutionMetropolis.fix_sampler"><code>fix_sampler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DifferentialEvolutionMetropolis.jl/blob/7ce0d18f8d8cd546c0541cda143f6fd5f1d37151/src/chains.jl#L274-L300">source</a></section></details></article><h3 id="Convergence-and-Stopping-Criteria"><a class="docs-heading-anchor" href="#Convergence-and-Stopping-Criteria">Convergence and Stopping Criteria</a><a id="Convergence-and-Stopping-Criteria-1"></a><a class="docs-heading-anchor-permalink" href="#Convergence-and-Stopping-Criteria" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DifferentialEvolutionMetropolis.r̂_stopping_criteria"><a class="docstring-binding" href="#DifferentialEvolutionMetropolis.r̂_stopping_criteria"><code>DifferentialEvolutionMetropolis.r̂_stopping_criteria</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">r̂_stopping_criteria(rng, model, sampler, samples, state, iteration; kwargs...)</code></pre><p>Stopping criterion based on the Gelman-Rubin diagnostic (R̂).</p><p>Sampling continues until the R̂ value for all parameters falls below <code>maximum_R̂</code>, indicating convergence across chains. This function is designed to be used as the <code>N_or_isdone</code> argument in <code>AbstractMCMC.sample</code> for adaptive stopping.</p><p>The diagnostic is computed on the last half of the collected samples to focus on the stationary portion of the chains.</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: Random number generator (unused but required by AbstractMCMC interface)</li><li><code>model</code>: The model being sampled (unused but required by interface)</li><li><code>sampler</code>: The differential evolution sampler (unused but required by interface)</li><li><code>samples</code>: Vector of collected samples from all chains</li><li><code>state</code>: Current sampler state (unused but required by interface)</li><li><code>iteration</code>: Current iteration number</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>check_every</code>: Frequency (in iterations) for checking R̂ values. Defaults to 1000.</li><li><code>maximum_R̂</code>: Maximum acceptable R̂ value for convergence. Defaults to 1.2.</li><li><code>maximum_iterations</code>: Maximum number of iterations before forced stopping. Defaults to 100000.</li><li><code>minimum_iterations</code>: Minimum iterations before convergence checking begins. Defaults to 0.</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if sampling should stop (converged or maximum iterations reached)</li><li><code>false</code> if sampling should continue</li></ul><p><strong>Example</strong></p><pre><code class="language- hljs">using DifferentialEvolutionMetropolis, AbstractMCMC, Random, Distributions

# Create a simple model
model_wrapper(θ) = logpdf(MvNormal([0.0, 0.0], I), θ)

# Setup sampler
sampler = deMCzs()

# Use with adaptive stopping criterion
rng = Random.default_rng()
chains = sample(rng, model_wrapper, sampler, r̂_stopping_criteria;
               n_chains=4, check_every=500, maximum_R̂=1.1)</code></pre><p>See also <a href="https://turinglang.org/MCMCDiagnosticTools.jl/stable/#MCMCDiagnosticTools.rhat"><code>MCMCDiagnosticTools.rhat</code></a>, <a href="#DifferentialEvolutionMetropolis.deMCzs"><code>deMCzs</code></a>, <a href="#DifferentialEvolutionMetropolis.DREAMz"><code>DREAMz</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DifferentialEvolutionMetropolis.jl/blob/7ce0d18f8d8cd546c0541cda143f6fd5f1d37151/src/convergence.jl#L1-L48">source</a></section></details></article><h3 id="Output"><a class="docs-heading-anchor" href="#Output">Output</a><a id="Output-1"></a><a class="docs-heading-anchor-permalink" href="#Output" title="Permalink"></a></h3><p>The output format can be modified with <code>chain_type</code>, the supported options are <code>Chains</code> from <a href="https://turinglang.org/MCMCChains.jl/stable/">MCMCChains</a>, <code>VNChain</code> from <a href="https://github.com/penelopeysm/FlexiChains.jl">FlexiChains</a>, <code>Any</code> which returns the basic <code>DifferentialEvolutionMetropolis.DifferentialEvolutionSample</code>, and the default option <code>DifferentialEvolutionOutput</code>. If <code>save_final_state = true</code> the format will be <code>(sample::requested format, final_state)</code>. If run in parallel using <code>step(model, sampler, parallel_option, n_its, n_meta_chains; n_chains = n_chains)</code> the meta chains and DE chains will be merged into one dimension for both <code>Chains</code> and <code>DifferentialEvolutionOutput</code>, if the final state is saved it will be a vector of length <code>n_meta_chains</code> containing the final state for each.</p><p>Note that support for <code>FlexiChains</code> is a bit underutilized as the all samplers currently require all of your parameters to have one type.</p><article><details class="docstring" open="true"><summary id="DifferentialEvolutionMetropolis.DifferentialEvolutionOutput"><a class="docstring-binding" href="#DifferentialEvolutionMetropolis.DifferentialEvolutionOutput"><code>DifferentialEvolutionMetropolis.DifferentialEvolutionOutput</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DifferentialEvolutionOutput{T &lt;: Real}</code></pre><p>Container for differential evolution MCMC sampling results.</p><p><strong>Fields</strong></p><ul><li><code>samples::Array{T, 3}</code>: Three-dimensional array of parameter samples with dimensions (iterations, chains, parameters). Each sample represents a point in parameter space from the MCMC chain.</li><li><code>ld::Matrix{T}</code>: Two-dimensional matrix of log-density values with dimensions (iterations, chains). Contains the log-probability density evaluated at each corresponding sample point.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T &lt;: Real</code>: Numeric type for the samples and log-density values (typically <code>Float64</code>).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Access samples from the output
output = sample(model, sampler, n_samples)
parameter_samples = output.samples  # Shape: (n_samples, n_chains, n_params)
log_densities = output.ld          # Shape: (n_samples, n_chains)

# Extract samples for a specific chain
chain_1_samples = output.samples[:, 1, :]  # All samples from chain 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GBarnsley/DifferentialEvolutionMetropolis.jl/blob/7ce0d18f8d8cd546c0541cda143f6fd5f1d37151/src/DifferentialEvolutionMetropolis.jl#L57-L83">source</a></section></details></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#DifferentialEvolutionMetropolis.DifferentialEvolutionOutput"><code>DifferentialEvolutionMetropolis.DifferentialEvolutionOutput</code></a></li><li><a href="#AbstractMCMC.step"><code>AbstractMCMC.step</code></a></li><li><a href="#AbstractMCMC.step_warmup"><code>AbstractMCMC.step_warmup</code></a></li><li><a href="#DifferentialEvolutionMetropolis.DREAMz"><code>DifferentialEvolutionMetropolis.DREAMz</code></a></li><li><a href="#DifferentialEvolutionMetropolis.deMC"><code>DifferentialEvolutionMetropolis.deMC</code></a></li><li><a href="#DifferentialEvolutionMetropolis.deMCzs"><code>DifferentialEvolutionMetropolis.deMCzs</code></a></li><li><a href="#DifferentialEvolutionMetropolis.fix_sampler"><code>DifferentialEvolutionMetropolis.fix_sampler</code></a></li><li><a href="#DifferentialEvolutionMetropolis.fix_sampler_state"><code>DifferentialEvolutionMetropolis.fix_sampler_state</code></a></li><li><a href="#DifferentialEvolutionMetropolis.r̂_stopping_criteria"><code>DifferentialEvolutionMetropolis.r̂_stopping_criteria</code></a></li><li><a href="#DifferentialEvolutionMetropolis.setup_de_update"><code>DifferentialEvolutionMetropolis.setup_de_update</code></a></li><li><a href="#DifferentialEvolutionMetropolis.setup_sampler_scheme"><code>DifferentialEvolutionMetropolis.setup_sampler_scheme</code></a></li><li><a href="#DifferentialEvolutionMetropolis.setup_snooker_update"><code>DifferentialEvolutionMetropolis.setup_snooker_update</code></a></li><li><a href="#DifferentialEvolutionMetropolis.setup_subspace_sampling"><code>DifferentialEvolutionMetropolis.setup_subspace_sampling</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="tutorial/">Sampling from multimodal distributions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 4 December 2025 11:16">Thursday 4 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
